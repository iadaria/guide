Установка Linux & MacOS
С помощью этой команды скачиваем скрипт, запускающий установку иструмента rustup,
который устанавливает последнюю стабильную версию языка Rust.
Перезапустите командную оболочку.

>curl https://sh.rustup.rs -sSf | sh

Обновление и деинсталяция Rust:
> rustup update\
> rustup self uninstall

> rustup --version

### New project
> cargo new <name>

### impl
- реалзиуем методы
- реализуем типаж в типе: 'impl Trait for Type {}'
- передаем типажи в качестве параметров функции: 'pub fn notify(item: impl Trait) {}' Этот параметр принимает любой
тип, реализующий указанный типаж.
- предыдущий пункт - синтаксический сахар от 'pub fn notify<T: Trait>(item: T) {}'. В этом коде больше слов.
Если функции передаются два одинаковых аргумента, то лучше использовать:'pub fn notify<T: Trait>(item1: T, item2: T) {}'
- Определяем notify что item должен реализовать как Display, так и Summary: 'pub fn notify(item: impl Summary + Display) {...}'
- Или то же самое, только через общий тип: 'pub fn notify<T: Summary + Display>(item: T) {...}'
- Более четкие границы  типажа с условием 'where':
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}

fn some_function<T, U>(t: T, u: U) -> i32
	where T: Display + Clone,
		U: Clone + Debug
{}
```
- Возвращаем 'fn returns_summarizable() -> impl Summary {...}'
- !Синтаксис 'impl Trait' позволяет кратко описать, что функция возвращает некий тип, реазлизующий типаж, без необходимости расписывать очень длинный тип
- Однако воспользоваться 'impl Trait' можно тлько если возвращаем один тип: например, получим ошибку если будем использовать 'if () { Tweet {...}} else { NewArticle {...}}'


### Lifecycle
- Структура. содержащая ссылку, поэтому ее определение нуждается в аннотации жизненного цикла
- !Эта аннотация означает, что экземпляр ImportantExcerpt не может пережить ссылку, которую он содержит в поле part.
```rust
struct ImportantExcept<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Izmail. A few years ago...");
    let first_sentence = novel.split('.').next().expect("Couldn't find '.'");

    let i = ImportantExcept {
        part: first_sentence,
    };
}
```
- Текст - этого строкового значения хранится непосредственно в двоичном файле программы, который всегда доступен. Следовательно, жизненным циклом всех\
строковых литералов является `static.
```rust
let s: &'static str = "У меня статический жизненный цикл.";
```

### Test
> cargo new <name> --lib
> cargo test

- Если значение является ложным, то макрокоманда assert! вызывает макрокоманду panic!, которая приводит к провалу тесат


### Замыкания
Замыкания языка Rust - это анонимные функции, которые можно сохранить в переменной или передавать в качестве аргумента другим функциям.
Мы можем создать замыкание в одном месте, а затем вызвать его для оценки в другом контексте. В отличии от функции, замыкания могут захватывать значения
из области видимости, в которой они определены. Эти средства обеспечивают повторное использование кода и индивидуализацию поведения.



```rust```
```rust```
```rust```
```rust```
```rust```
```rust```
```rust```